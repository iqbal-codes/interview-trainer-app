import { NextResponse } from 'next/server';
import { interviewSetupSchema } from '@/lib/validations/interview';
import { cookies } from 'next/headers';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { Database } from '@/lib/supabase/types';
import { generateInterviewQuestions } from '@/lib/services/googleService';

export async function POST(request: Request) {
  try {
    // Initialize Supabase client
    const supabase = createRouteHandlerClient<Database>({ cookies });

    // Check authentication
    const {
      data: { session },
    } = await supabase.auth.getSession();

    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const userId = session.user.id;

    // Parse and validate the request body
    const body = await request.json();

    try {
      // Validate the input
      const validatedData = interviewSetupSchema.parse({
        ...body,
        key_skills_focused: Array.isArray(body.key_skills_focused)
          ? body.key_skills_focused.join(',')
          : body.key_skills_focused,
      });

      // Process key_skills_focused as an array
      const skills = Array.isArray(validatedData.key_skills_focused)
        ? validatedData.key_skills_focused.map(skill => skill.trim())
        : [validatedData.key_skills_focused.trim()];

      // Create a new interview session in the database
      const { data: sessionData, error: sessionError } = await supabase
        .from('interview_sessions')
        .insert({
          user_id: userId,
          target_role: validatedData.target_role,
          key_skills_focused: skills,
          interview_type: validatedData.interview_type,
          job_description_context: validatedData.job_description_context || null,
          requested_num_questions: validatedData.requested_num_questions,
          status: 'pending',
          session_name: `${validatedData.interview_type} Interview for ${validatedData.target_role}`,
        })
        .select()
        .single();

      if (sessionError) {
        console.error('Error creating interview session:', sessionError);
        return NextResponse.json({ error: 'Failed to create interview session' }, { status: 500 });
      }

      const sessionId = sessionData.id;

      // Get user's CV content for context if available
      const { data: profileData } = await supabase
        .from('profiles')
        .select('cv_text_content')
        .eq('user_id', userId)
        .single();

      const cvContext = profileData?.cv_text_content || '';

      try {
        // Generate interview questions using the googleService
        const questions = await generateInterviewQuestions(
          validatedData.interview_type,
          validatedData.requested_num_questions,
          skills,
          validatedData.job_description_context || undefined,
          cvContext || undefined
        );

        // Ensure we have at least some questions
        if (questions.length === 0) {
          return NextResponse.json(
            { error: 'Failed to generate valid questions from LLM' },
            { status: 500 }
          );
        }

        // Limit to the requested number of questions
        const limitedQuestions = questions.slice(0, validatedData.requested_num_questions);

        // Save questions to the database
        const questionsToInsert = limitedQuestions.map((questionText, index) => ({
          session_id: sessionId,
          question_text: questionText,
          question_order: index + 1,
          question_type_tag: validatedData.interview_type.toLowerCase().replace(' - ', '_'),
        }));

        const { data: insertedQuestions, error: questionsError } = await supabase
          .from('interview_questions')
          .insert(questionsToInsert)
          .select();

        if (questionsError) {
          console.error('Error inserting questions:', questionsError);
          return NextResponse.json(
            { error: 'Failed to save generated questions' },
            { status: 500 }
          );
        }

        // Update the session with the actual number of questions and status
        await supabase
          .from('interview_sessions')
          .update({
            actual_num_questions: limitedQuestions.length,
            status: 'ready_to_start',
          })
          .eq('id', sessionId);

        // Format the response
        const formattedQuestions = insertedQuestions.map(q => ({
          id: q.id,
          question_text: q.question_text,
          order: q.question_order,
        }));

        return NextResponse.json(
          {
            message: 'Interview session created and questions generated by LLM.',
            session_id: sessionId,
            questions: formattedQuestions,
          },
          { status: 201 }
        );
      } catch (llmError) {
        console.error('Error calling LLM:', llmError);
        return NextResponse.json(
          { error: 'Failed to generate questions with LLM' },
          { status: 500 }
        );
      }
    } catch (validationError) {
      console.error('Validation error:', validationError);
      return NextResponse.json({ error: 'Invalid request data' }, { status: 400 });
    }
  } catch (error) {
    console.error('Error generating interview:', error);
    return NextResponse.json({ error: 'Failed to generate interview' }, { status: 500 });
  }
}
